void swap(int* num1, int* num2)//Задължително трябва да е с указатели (или псевдоними), за да е коректна смяната, иначе не праивм нищо
{
	int temp = *num1;
	*num1 = *num2;
	*num2 = temp;
}

int main(){
int arr[N];
	for (int i = 0; i < N; i++)
		cin >> arr[i];

	int count = 0;//броят а вече наредените двойки в масива (1 елемент с последен, 2 с предпоследен и т.н.)
	int alone = 0;//броят на самотните числа
	bool dali = true;//С това прверяваме дали числото, а кеото сме при итерацията си има двойник в масива
	for (int i = 0; i < N - 1 - count; i++)
	{
		dali = true;
		for (int j = i + 1; j < N - count; j++)
		{
		if (arr[j] == arr[i])//Търсим дали i-тия елемент си има двойник в масива. Ако има слагаме i-тие елемент на позиция count, а двойника му на позиция N-1-count
			{
				dali = false;
        if(alone==1)
        //Лявата смяна няма смисъл да я правим освен ако не сме намерили "самотно" число при търсенето на предходното число 
        //и сега вече е нужно да поставим ново чило на негово място
				swap(arr[count], arr[i]);
        if(j!=N-1-count)//Няма смисъл да правим дясната смяна, ако съвпадат позициите елементите
				swap(arr[N - 1 - count], arr[j]);
				count++;
				break;
			}
		}
		if (dali) alone++;
		if ((alone == 1 && N % 2 == 0) || alone == 2)//Ако масивът е четен с едно единично число или нечетен с две, няма как да стане палиндром
		{
			dali = false;
			cout << "The number cannot become a palindrome" << endl;
			break;
		}
		if (i + 1 >= N - 1 - count) {//Ако вече няма какво повече да проверяваме в масива (всичко надясно от i вече е подредено)
			cout << "The number can become a palindrome" << endl; dali = true;
		}
	}
	if (dali)
	{
		for (int i = 0; i < N; i++)
			cout << arr[i] << " ";
	}
  }
