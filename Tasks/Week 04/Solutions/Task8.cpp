	int arr[N];
	int arr2[N]; 
	int result[N];

int counter = 0;//Трябва ни за масива, в който ще запазим сечението
int copy = N;

for (int i = 0; i < N; i++)
	cin >> arr[i];


for (int i = 0; i < N; i++)
	cin >> arr2[i];

//Спокойно, от тук започва задачата

for (int i = 0; i < N; i++)
{
//Сравняваме всеки елемент от първия с всеки елемент от втрия масив	
	for (int j = 0; j < copy; j++)
	{
		if (arr[i] == arr2[j])
		{
			result[counter] = arr[i];//Запиваме го така с counter, за да знаем после до къде да итерираме в резултатния масив
			counter++;
			for (int k = j; j < copy - 1; j++)
			{
      //Цялата идея на този цикъл е, че, ако в първия масив имаме да кажем две седмици, а във втория една, сечението е само едната седмица и, ако не го съобразим,
      //за дадено i ще намерим първата седмица във втория масив, обаче за друго i, отнова ще попаднем на тази седмица и така сечението ще съдържа и двете, което не е вярно
      //Затова елиминираме седмицата от втория масив, както направихме и в 7-ма задача
				arr2[j] = arr2[j + 1];
			}
			copy--;
			break;//Намерили сме вече сечение, няма смисъл да продължаваме, защото, ако има втори такъв елемент във втория масив, би се получил пък обратния случай на този,
      //описна по-горе
		}
	}

}
for (int i = 0; i < counter; i++)
	cout << result[i] << " ";
