
/*Ваш колега си е направил функция, която създава геометрична прогресия. Но за нещастие оплескал кода си,
така че понякога в една от неговите прогресии се вмъкват и други елементи, които не принадлежат на нея. 
Ваша работа е да филтрирате подадения масив, така че да образува геометрична прогресия спрямо първите си два елемента.
След като филтрирате масива проверете дали елементите, които сте премахнали образуват аритметична прогресия и върнете тази стойност.
Напишете подходяща функция, която изпълнява тези изисквания.

Пример:
Вход:
{2, 4, 5,  8, 10, 15, 16, 20,  32, 64, 128} 
Резултат: геометрична{2, 4, 8, 16, 32, 64, 128}
   филтрирани{5, 10, 15, 20}
   образуват ли аритметична прогресия - да
*/
const int N = 10;

bool isArithmetic(int* arr, int size)
{
 if(arr[0] == 0)
  {
    return 0;
  }
	if (size <= 2)//базов случай; връщаме истина, ако няма елементи за втората прогресия
	{
		return 1;
	}
	int countDel = 0;
	int del[N - 2];
	double quotient = double(arr[1]) / double(arr[0]);
	for (int i = 2; i < size; i++)//филтрираме масива на геометричната прогресия
	{
		if (arr[i - 1] * quotient != arr[i])
		{
			del[countDel++] = arr[i];//директно се увеличава counterDel заради ++
			for (int j = i; j < size - 1; j++)//премахване на елемент
			{
				arr[j] = arr[j + 1];
			}
			i--;
			size--;
		}
	}
	if (countDel < 2)
	{
		return 1;
	}
	int diff = del[1] - del[0];
	for (int i = 2; i < countDel; i++)
	{
		if (del[i] - del[i - 1] != diff)
		{
			return 0;
		}
	}
	return 1;
}
